import express from "express";
import bcrypt from "bcrypt";
import crypto from "crypto";
import jwt from "jsonwebtoken";
import dotenv from "dotenv";
import sendEmail from "../utils/sendEmail.js";
import pgClient from "../db.js";

dotenv.config();

const router = express.Router();

const createSchema = async (businessID) => {
  await pgClient.query(
    `
    CREATE SCHEMA business_${businessID}

      CREATE TABLE items (
        code bigint PRIMARY KEY NOT NULL,
        brand text NOT NULL,
        specs text NOT NULL,
        qty int CHECK(qty >= 0) NOT NULL,
        unit_price numeric NOT NULL,
        unit text NOT NULL,
        reorder_point int NOT NULL,
        date_time timestamp DEFAULT now()
      )

      CREATE TABLE restock_records (
        restock_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY NOT NULL,
        item_code bigint REFERENCES business_${businessID}.items(code) NOT NULL,
        additional_qty int CHECK(additional_qty >= 0) NOT NULL,
        user_id int REFERENCES users(id) NOT NULL,
        restock_date_time timestamp DEFAULT now()
      )
      
      CREATE INDEX restock_code_fkey ON restock_records (item_code)
      
      CREATE INDEX restock_user_id_fkey ON restock_records (user_id)

      CREATE TABLE transactions (
        id bigint PRIMARY KEY NOT NULL,
        user_id int REFERENCES users(id) NOT NULL,
        date_time timestamp DEFAULT now(),
        total numeric DEFAULT 0 NOT NULL 
      )
      
      CREATE INDEX transactions_user_id_fkey ON transactions (user_id)
      
      CREATE TABLE item_transactions (
        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY NOT NULL,
        transaction_id bigint REFERENCES business_${businessID}.transactions(id) NOT NULL, 
        item_code bigint REFERENCES business_${businessID}.items(code) NOT NULL,
        qty int NOT NULL,
        total_price numeric NOT NULL
      )

      CREATE INDEX item_transactions_id_fkey ON item_transactions (transaction_id);
      
    `,
  );
};

router
  .post("/login", async (req, res) => {
    try {
      const { email, password } = req.body;

      const { rows } = await pgClient.query(`
        SELECT id, role_id, business_id, fname, lname, email, password, is_verified
        FROM users WHERE email = $1`,
      [email]);

      if (rows.length === 0) {
        return res.json({ success: false, message: "Account not found." });
      }

      if (rows.length === 1 && !rows[0].is_verified) {
        return res.json({ success: false, message: "Account not verified" });
      }

      const validPassword = await bcrypt.compare(password, rows[0].password);

      if (!validPassword) {
        return res.json({ success: false, message: "Incorrect email/password" });
      }

      Reflect.deleteProperty(rows[0], "password");
      const expiresIn = "2h";
      const token = jwt.sign(rows[0], process.env.JWT_SECRET, {
        algorithm: "HS256",
        expiresIn,
      });

      return res.json({ success: true, token, expiresIn });
    } catch (error) {
      console.log(error);
      return res.sendStatus(500);
    }
  })
  // ADMIN SIGNUP
  .post("/signup", async (req, res) => {
    try {
      const verificationToken = crypto.randomBytes(64).toString("hex");
      const {
        email, password, fname, lname, businessName,
      } = req.body;

      const users = await pgClient.query(
        "SELECT email FROM users WHERE email = $1;",
        [email],
      );

      if (users.rowCount > 0) {
        return res.json({
          success: false,
          message: "Email has already been used.",
        });
      }

      const { rows: businesses } = await pgClient.query(
        "INSERT INTO businesses (name) VALUES ($1) RETURNING id;",
        [businessName],
      );

      const businessID = businesses[0].id;
      const hashedPassword = await bcrypt.hash(password, 10);
      await pgClient.query(
        "INSERT INTO users (role_id, business_id, email, password, fname, lname, verification_token) VALUES ($1, $2, $3, $4, $5, $6, $7);",
        [
          1,
          businessID,
          email,
          hashedPassword,
          fname,
          lname,
          verificationToken,
        ],
      );

      await createSchema(businessID);

      const verificationMsg = `
      <p>Hello ${fname}!<br>Please verify that your email is ${email}, and that you entered it when signing up for VISION Inventory Management System.
      <a href="http://localhost:3000/auth/verify-email?token=${verificationToken}&type=admin">
      <br><input type="submit" value="Verify Email" /></a>
      </p>`;
      const subject = "Email Verification for VISION Inventory";
      sendEmail(verificationMsg, subject, email);

      return res.json({
        success: true,
        message: "A verification link has been sent to your email account.",
      });
    } catch (error) {
      console.log(error);
      return res.sendStatus(500);
    }
  })
  .patch("/verify-email", async (req, res) => {
    try {
      const reqVerificationToken = req.query.token;

      const { rows: users } = await pgClient.query(
        "SELECT * FROM users WHERE verification_token = $1",
        [reqVerificationToken],
      );

      if (users.length === 0) {
        return res.json({ success: false, message: "Invalid request." });
      }

      if (users[0].is_verified) {
        return res.json({
          success: false,
          message: "Email has already been verified.",
        });
      }

      const { rows } = await pgClient.query(
        "UPDATE users SET is_verified = true WHERE id = $1 RETURNING role_id",
        [users[0].id],
      );

      if (rows[0].role_id !== 1) {
        return res.json({
          success: true,
          type: "employee",
          message: "Redirecting to employee sign in...",
        });
      }

      return res.json({ success: true, type: "admin", message: "Email verified successfully!" });
    } catch (error) {
      console.log(error);
      return res.sendStatus(500);
    }
  })
  .patch("/signup/emp", async (req, res) => {
    try {
      const verificationToken = req.query.token;
      const { password } = req.body;
      const hashedPassword = await bcrypt.hash(password, 10);

      const { rows } = await pgClient.query(
        "UPDATE users SET password = $1 WHERE verification_token = $2 RETURNING true",
        [hashedPassword, verificationToken],
      );

      if (rows.length === 0) {
        return res.send(400).json({ success: false, message: "Invalid request" });
      }

      return res.json({
        success: true,
        message: "Password successfully changed.",
      });
    } catch (error) {
      console.log(error);
      return res.sendStatus(500);
    }
  });

export default router;
